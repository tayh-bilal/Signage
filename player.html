// Define the path for the backup file
    const cachePath = path.join(baseDir, 'cached-playlist.json');

    async function syncVideos() {
        console.log("Checking playlist...");
        try {
            // 1. Try to get the live playlist from the internet
            const requestStart = Date.now();
            const res = await fetch(playlistUrl);
            const requestEnd = Date.now();
            
            // --- SYNC LOGIC (Only runs if online) ---
            const networkDelay = (requestEnd - requestStart) / 2;
            const serverDateStr = res.headers.get('Date');
            if (serverDateStr && (requestEnd - requestStart) < 1000) {
                 const serverTime = new Date(serverDateStr).getTime();
                 serverTimeOffset = serverTime - (requestEnd - networkDelay);
            }
            // ----------------------------------------

            const data = await res.json(); 
            
            // 2. SAVE TO BACKUP (The "Offline Memory")
            // We save this file every time we get a good response
            try {
                fs.writeFileSync(cachePath, JSON.stringify(data));
            } catch (e) { console.log("Could not save backup:", e); }

            // --- AUTO-UPDATE LOGIC ---
            if (data.version) {
                const remoteVer = data.version.replace('v', '');
                const localVer = currentAppVersion.replace('v', '');
                if (remoteVer !== localVer && !updateTriggered) {
                    updateTriggered = true;
                    ipcRenderer.send('trigger-update');
                }
            }

            processPlaylist(data);

        } catch (err) {
            console.log("Offline or Sync error:", err);

            // 3. OFFLINE RECOVERY
            // If we have no videos (just rebooted) and no internet, load the backup!
            if (videos.length === 0 && fs.existsSync(cachePath)) {
                console.log("⚠️ Internet down. Loading backup playlist...");
                try {
                    const cachedData = JSON.parse(fs.readFileSync(cachePath, 'utf8'));
                    processPlaylist(cachedData);
                } catch (e) {
                    console.log("Backup file corrupted.");
                }
            }
            
            // Retry slowly (every 15s) until internet comes back
            startPolling(15000); 
        }
    }

    // Helper function to process the list (used by both Online and Offline modes)
    async function processPlaylist(data) {
        const list = data.videos || [];
        if (list.length > 0) {
            for (let v of list) {
                const dest = path.join(localFolder, v.file);
                // Only download if missing
                if (!fs.existsSync(dest)) {
                    // Note: If offline, this download will fail, but that's okay 
                    // because we only need files that were ALREADY downloaded.
                    if (navigator.onLine) { 
                        await new Promise(r => {
                            const f = fs.createWriteStream(dest);
                            https.get(v.url, res => { res.pipe(f); f.on('finish', () => { f.close(); r(); }); }).on('error', r);
                        });
                    }
                }
                
                // Calculate duration
                v.duration = await new Promise(resolve => {
                    const temp = document.createElement('video');
                    temp.src = dest;
                    temp.onloadedmetadata = () => resolve(temp.duration);
                    // If file is corrupt or missing, give it 0 duration so we skip it
                    temp.onerror = () => resolve(0); 
                });
            }
            // Filter out any broken/missing videos so the player doesn't freeze
            videos = list.filter(v => v.duration > 0);
            
            startPolling(60000); 
            playSync();
        } else {
            videos = [];
            startPolling(10000); 
            playSync();
        }
    }